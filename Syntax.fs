module Syntax
// Однорядкові коментарі починаються з подвійного прямого слеша
(*  Багаторядкові коментарі
   починаються з (*
   та закінчуються на *)
*)

//// Значення ("змінна", яка не змінює свого значення після створення)
let myInt = 5
let myFloat = 3.14
let myString = "hello"  // Зверніть увагу, типи вказувати не потрібно

//// Списки
// Квадратні дужки створюють список, в якості роздільника виступає ";"
let twoToFive = [2; 3; 4; 5]
// :: додає 1 до існуючого списку та повертає результат додавання список, який записується в oneToFive
let oneToFive = 1 :: twoToFive
// oneToFive містить [1; 2; 3; 4; 5]
// "@" з'єднує 2 списки разом та повертає результат з'єднування
let zeroToFive = [0; 1] @ twoToFive
// zeroToFive містить [0; 1; 2; 3; 4; 5]
// Варто зазначити, що коми ніколи не виступают у якості роздільника у літералах колекцій

//// Функції
// let застосовується не тільки для декларування значень, а й ще для створення функцій
// Декларування функції не потребує використання дужок та ком, параметри розділяються пробілами
// і знову - типи вказувати не потрібно!
let square x = x * x
// Щоб виконати функцію, треба просто записати її ім'я з достатьної кількістю аргументів через пробіл
square 3 |> ignore
// Функції можуть мати більше 1 параметра
let add x y = x + y
add 2 3 |> ignore
// Не використовуйте запис add (x, y). Він має абсолютно інше значення, хоч і скомпілюється
// Для того, щоб визначити функцію що має більше 1 вираза, використовуйте відступи
let evens list =
  let isEven x = x % 2 = 0
  List.filter isEven list    // List.filter - бібліотечна функція, що вибирає елементи, які задовольняють умову
// Зверніть увагу - isEven є вкладеною в evens функцію. Функція може мати скільки завгодно
// вкладених значень та функцій
// Виконуємо функцію:
evens oneToFive |> ignore
// Можна використовувати дужки щоб визначити порядок виконання дій явно
// В даному випадку спочатку виконається "map", а вже потім результат буде передано в функцію "sum"
let sumOfSquaresTo100 =
  List.sum ( List.map square [1..100] )
// Спеціальній оператор "|>" (pipe) використовується щоб позбавитися від дужок
// він дословно означає "передай те що зліва як аргумент до того, що справа"
// тобто "a |> b |> c" означає те ж саме, що й "c ( b ( a ) )""
let sumOfSquaresTo100piped =
  [1..100] |> List.map square |> List.sum
// Щоб створити анонімну функцію (lambda function), слід використовувати ключове слово fun
// fun x -> x * x аналогічно функції square, що була задекларована раніша
let sumOfSquaresTo100withFun =
  [1..100] |> List.map (fun x -> x * x) |> List.sum
// В F# кожна функція завжди повертає результат останнього написаного вираза. Навіть функції,
// що нічого явно не вертають, повертають unit (логічне "нічого", аналог void)

//// Співвідношення зі зразком (pattern matching)
// Це дуже схоже на звичайний switch .. case, проте набаго гнучкіший та потужний
let simplePatternMatch =
  let x = "a"
  match x with
  | "a" -> printfn "x is a"
  | "b" -> printfn "x is b"
  | _ -> printfn "x is something else"   // "_" - означає будь що, аналог default
// Some(..) та None - спеціальний тип Option,
// якbй дуже схожі на "типи, що допускають null" (Nullable types) в C#
let validValue = Some(99)
let invalidValue = None
// Pattern matching може використовуватися щоб перевірити, чи є значення Some(...) або None
// а також дозволяє "розпакувати" значення, що знаходиться в Some
let optionPatternMatch input =
  match input with
  | Some i -> printfn "Input is an int = %d" i
  | None -> printfn "Input is missing"
// Запустимо функції для перевірки
optionPatternMatch validValue
optionPatternMatch invalidValue

//// Складні типи даних
// Кортежі (tuples) утворють "пари", "трійкі", можуть мати різнотипні елементи.
// Елементи розділяються за допомогою коми
let twoTuple = 1, 2
let threeTuple = "a", 2, true
// Записи схожі на кортежі, які мають імена для своїх елементів.
// в якості роздільника використовується ";"
// Спочатку задається тип з розміченими полями
type Person = { First : string; Last : string}
// потім створється запис з такими полями
let person1 = { First = "Andrii"; Last = "Rublov"}
// Об'єднання (unions) представляють собою вибір одного з варіантів.
// в якості роздільника варіантів використовується "|"
type Temp =
| DegreesC of float
| DegreesF of float
// Значення типу Temp можуть бути або DegreesC, або DegreesF
// в даному випадку - DegreesF
let temp = DegreesF 98.6
// Типи можуть бути об'єднаними у складні структури типів
// Наприклад ми можемо створити рекурсивний тип, який відображує дерево співробітників
type Employee =
| Worker of Person
| Manager of Employee list
let arublov = { First = "Andrii"; Last = "Rublov"}
let worker = Worker arublov

//// Вивід на екран
// Функції printf/printfn дуже схожі на свої аналоги в С
printfn "Printing an int %i, a float %f, a bool %b" 1 2.0 true
printfn "A string %s, and something generic %A" "hello" [1;2;3;4]
// Усі вбудовані типи даних мають форматований вивід, якщо в якості формату задати "%A"
printfn "twoTuple=%A,\nPerson=%A,\nTemp=%A,\nEmployee=%A"
        twoTuple person1 temp worker
// Крім того, існує функція sprintf, яка не виводить на екран, а повертає формативану версію строки
// аналог String.Format в C#